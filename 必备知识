前置知识解释：
操作系统的启动过程
     1. 加电和自检
     当计算机加电后，首先执行的是自检过程。这一过程由计算机的固件，通常是BIOS（基本输入输出系统）或UEFI（统一可扩展固件接口）控制。
     自检包括检查计算机的硬件配置，如内存、处理器、外设等，确保没有硬件错误。
     2. 寻找启动设备
     自检完成后，BIOS/UEFI将根据预设的启动顺序来寻找可启动的设备，这些设备可以是硬盘、SSD、光驱、USB设备或网络等。
     3. 加载引导程序
     引导程序（Bootloader）也叫MBR程序。是存储在启动设备上的一个小程序，其主要任务是加载操作系统。
     4. 加载操作系统内核
     引导程序首先加载操作系统的内核。内核是操作系统的核心部分，负责管理计算机的硬件资源，并提供系统服务给应用程序。   
     内核加载到内存中后，会初始化硬件设备，创建和启动系统进程，然后开始运行系统的其他组件。
     5. 系统初始化   
     操作系统内核加载并运行后，会继续加载系统的其他组件，如设备驱动程序和系统服务。
     此外，它还会启动用户界面，如图形界面（GUI）或命令行界面（CLI），以便用户与系统交互。
     6. 用户登录
     最后，操作系统会显示登录界面，等待用户登录。用户成功登录后，操作系统就完成了启动过程，用户可以开始使用计算机进行各种操作。


  一句话总结：硬盘有一块儿地方固定着一段代码，通电后，只要设备没坏，这段代码就会被执行，这段代码叫引导程序，它的作用是负责将硬盘
      里的操作系统加载到内存中执行。


  硬盘镜像文件是什么
      类似与虚拟机的概念，这个文件相当与一个虚拟的硬盘，存放着引导程序与操作系统。可以把他看作一块真实的硬盘，里面放着操作系统。
    （重装系统的时候不就是拿个u盘，u盘里放着需要装的系统嘛，硬盘镜像文件就差不多是这个理儿）
8086型号cpu的几个基本寄存器
| 寄存器 | 高   | 低   | 作用  寄存器就是一位位比特位的组合，用于存放0和1表示数据                                                        
| :----- | ---- | ---- | ----------------------------------------------------------   
| ax     | ah   | al   | 累加器 ，用于存放算术和逻辑运算的结果                           
| bx     | bh   | bl   | 基址寄存器 ，可以用作指针或存放数据。                           
| cx     | ch   | cl   | 计数器 ，常用于循环计数器。                                   
| dx     | dh   | dl   | 数据寄存器 ，可用作输入输出端口的指针。                         
| sp     |      |      | 堆栈指针 ，指向堆栈区的栈顶。                                  
| bp     |      |      | 基址指针 ，通常用作堆栈帧指针，指向函数调用时的参数和局部变量。   
| si     |      |      | 源变址寄存器 ，用于字符串操作中的源地址。                       
| di     |      |      | 目的变址寄存器 ，用于字符串操作中的目的地址。                   
|        |      |      | 以上这些寄存器为16位，可分为高8位与低8位。                     
| cs     |      |      | 代码段寄存器：存放程序代码的段地址。                          
| ds     |      |      | 数据段寄存器：存放数据的段地址。                             
| es     |      |      | 堆栈段寄存器：存放堆栈的段地址。                             
| ss     |      |      | 附加段寄存器：进一步扩展数据存储能力时使用的段地址。           
|        |      |      |    
寻址方式介绍：
真实物理地址=段基址+偏移量
8086架构的CPU地址线有20根，但寄存器只有16位，理论上只能访问2^16个地址，就是64KB大小的内存空间。
但是，我们把取到的16位数放到20根地址线的前16位，这时就空下了后4位，然后我们在这基础上，再加一个数。这时，这20位地址线就可以全部使用上。
在最大时 1111 1111 1111 1111 0000 + 0000 0000 0000 1111 = 1111 1111 1111 1111 1111 从0~1111 1111 1111 1111 1111为2^20。
这样能够实际访问到的物理地址最大为 1111 1111 1111 1111 1111也就是1MB大小的内存空间。
上述过程中，第二次加的那个数便叫作偏移量。
可以理解为 最多 1111个人为一组，最多有1111 1111 1111 1111组，这样最多有1048576人。而1048576种状态用二进制位20位刚好可以表示。
实模式：
一台裸机，没有安装任何操作系统，我们可以编写汇编语言程序，写好汇编为二进制文件，直接交给cpu执行。这种模式下可以访问的内存为1MB。
我们是用汇编语言直接控制的cpu的寄存器。这种情况就叫实模式，程序员手动管理cpu。
关于1MB的内存空间
实模式下cpu能直接访问的这1MB空间是个比较特殊的空间。

| 起始地址  | 结束地址  | 大小     | 用途               |
| --------- | --------- | -------- | ------------------ |
| `0x000`   | `0x3FF`   | 1KB      | 中断向量表         |
| `0x400`   | `0x4FF`   | 256B     | BIOS 数据区        |
| `0x500`   | `0x7BFF`  | 29.75 KB | 可用区域           |
| `0x7C00`  | `0x7DFF`  | 512B     | MBR 加载区域       |
| `0x7E00`  | `0x9FBFF` | 607.6KB  | 可用区域           |
| `0x9FC00` | `0x9FFFF` | 1KB      | 扩展 BIOS 数据区   |
| `0xA0000` | `0xAFFFF` | 64KB     | 用于彩色显示适配器 |
| `0xB0000` | `0xB7FFF` | 32KB     | 用于黑白显示适配器 |
| `0xB8000` | `0xBFFFF` | 32KB     | 用于文本显示适配器 |
| `0xC0000` | `0xC7FFF` | 32KB     | 显示适配器 BIOS    |
| `0xC8000` | `0xEFFFF` | 160KB    | 映射内存           |
| `0xF0000` | `0xFFFEF` | 64KB-16B | 系统 BIOS          |
| `0xFFFF0` | `0xFFFFF` | 16B      | 系统 BIOS 入口地址 |


