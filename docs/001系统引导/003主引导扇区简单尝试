再来复习一下操作系统启动的过程，硬盘一个地方固定着一段代码BIOS，一通电这段代码就会被执行。
这段代码负责检测硬件设备，没有问题的话，它就会把MBR程序加载到内存，MBR负责引到操作系统，
接下来我们写一个非常简单的MBR程序，先暂时不引导，只是把一个裸机启动让它能在屏幕上显示点东西。

[org 0x7c00];确保程序的起始地址是这个0x7c00
;为什么是这个地址呢？   约定，就是行业都遵循的协议。而且上边前置知识也说了，在实模式下，
;我们通过汇编语言能够直接控制cpu访问的这1MB的内存大小，是比较特殊的，有固定用处，这个0x7c00就是固定的，
;必须要把MBR程序加载到这里
;mov a b 这段代码意思是把b的值赋给a

mov ax, 3;这是把3这个值放入ax这个寄存器
int 0x10;这是BIOS程序提供的调用，他会读取ax寄存器的值，根据值为多少，从而做出反馈，
        ;作用就是设置屏幕模式为文本模式，清除屏幕。

; 初始化段寄存器，当屏幕进入文本模式后，我们需要把这几个寄存器的值归零，以便后续使用。
mov ax, 0
mov ds, ax
mov es, ax
mov ss, ax
mov sp, 0x7c00
;忘记这几个寄存器作用的，可以去看002前置知识

;解释一下，0xb800是文本显示器的内存区域，什么意思呢，就是通过内存映射技术，
;我们操作这个地方的内存，就相当于在操控显存。显存被划分为一个个字符单元，每个字符单元占用2个字节，
;其中一个字节存储字符的ASCII码，另一个字节存储字符的显示属性（比如前景色和背景色）。
;0xB800 是显存的起始地址，通过对这个地址的读写操作，可以直接在屏幕上显示字符。
;这也呼应前文我说的，实模式下cpu能够直接访问的这个1MB大小的内存是有特殊作用的。
mov ax, 0xb800
mov ds, ax
mov byte [0], 'H'  ; 字符 'H'

jmp $;使程序阻塞到这里不动，持续显示字符


times 510 - ($ - $$) db 0
;在当前位置到程序起始位置之间插入足够多的字节（使用0填充），以使整个引导扇区的大小达到512字节。
;这样做是为了确保引导扇区的大小是标准的512字节，符合引导扇区的规范要求。
;MBR程序必须为512字节，规定，且最后两个字节必须是0x55 0xaa以表示这是引导程序

db 0x55 0xaa

最后，MBR程序后缀为.asm
比如  hello.asm
